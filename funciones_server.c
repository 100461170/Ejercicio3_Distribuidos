/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "funciones.h"
#include "servidor.c"
#include <pthread.h>
// variable para inicializar sevidor
int server_initialized = 0;
// inicializar mutex
pthread_mutex_t mutex_server = PTHREAD_MUTEX_INITIALIZER;

bool_t
init_1_svc(int *result, struct svc_req *rqstp)
{
	bool_t retval;
	// inicializar servidor
	pthread_mutex_lock(&mutex_server);
	if (server_initialized <= 0)
	{
		int server_status = server_init();
		if (server_status == -1)
		{
			*result = -1;
			pthread_mutex_unlock(&mutex_server);
			return -1;
		}
		else
		{
			server_initialized = server_status;
		}
	}

	pthread_mutex_unlock(&mutex_server);
	// crear peticion
	struct peticion pet = {.op = 0};
	// obtener resultado
	struct respuesta resp_pet;
	tratar_peticion(pet, &resp_pet);
	*result = resp_pet.status;
	retval = 1;

	return retval;
}

bool_t
set_value_1_svc(struct peticion arg1, int *result, struct svc_req *rqstp)
{
	bool_t retval;
	// inicializar servidor
	pthread_mutex_lock(&mutex_server);
	if (server_initialized <= 0)
	{
		int server_status = server_init();
		if (server_status == -1)
		{
			*result = -1;
			pthread_mutex_unlock(&mutex_server);
			return -1;
		}
		else
		{
			server_initialized = server_status;
		}
	}
	pthread_mutex_unlock(&mutex_server);
	arg1.op = 1;
	// obtener resultado
	struct respuesta resp_pet;
	tratar_peticion(arg1, &resp_pet);
	*result = resp_pet.status;
	retval = 1;
	return retval;
}

bool_t
get_value_1_svc(struct peticion arg1, struct respuesta *result, struct svc_req *rqstp)
{
	bool_t retval;
	// inicializar servidor
	pthread_mutex_lock(&mutex_server);
	if (server_initialized <= 0)
	{
		int server_status = server_init();
		if (server_status == -1)
		{
			pthread_mutex_unlock(&mutex_server);
			return -1;
		}
		else
		{
			server_initialized = server_status;
		}
	}
	pthread_mutex_unlock(&mutex_server);
	arg1.op = 2;
	struct respuesta resp;
	// obtener resultado
	tratar_peticion(arg1, &resp);
	*result = resp;
	retval = 1;
	return retval;
}

bool_t
modify_value_1_svc(struct peticion arg1, int *result, struct svc_req *rqstp)
{
	bool_t retval;
	// inicializar servidor
	pthread_mutex_lock(&mutex_server);
	if (server_initialized <= 0)
	{
		int server_status = server_init();
		if (server_status == -1)
		{
			*result = -1;
			pthread_mutex_unlock(&mutex_server);
			return -1;
		}
		else
		{
			server_initialized = server_status;
		}
	}
	pthread_mutex_unlock(&mutex_server);

	arg1.op = 3;
	// obtener resultado
	struct respuesta resp_pet;
	tratar_peticion(arg1, &resp_pet);
	*result = resp_pet.status;
	retval = 1;
	return retval;
}

bool_t
delete_key_1_svc(int key, int *result, struct svc_req *rqstp)
{
	bool_t retval;
	// inicializar servidor
	pthread_mutex_lock(&mutex_server);
	if (server_initialized <= 0)
	{
		int server_status = server_init();
		if (server_status == -1)
		{
			*result = -1;
			pthread_mutex_unlock(&mutex_server);
			return -1;
		}
		else
		{
			server_initialized = server_status;
		}
	}

	pthread_mutex_unlock(&mutex_server);
	// crear peticion
	struct peticion pet;
	memset(&pet, 0, sizeof(struct peticion));
	pet.op = 4;
	pet.key = key;
	// obtener resultado
	struct respuesta resp_pet;
	tratar_peticion(pet, &resp_pet);
	*result = resp_pet.status;
	retval = 1;
	return retval;
}

bool_t
exist_1_svc(int key, int *result, struct svc_req *rqstp)
{
	bool_t retval;
	// inicializar servidor
	pthread_mutex_lock(&mutex_server);
	if (server_initialized <= 0)
	{
		int server_status = server_init();
		if (server_status == -1)
		{
			*result = -1;
			pthread_mutex_unlock(&mutex_server);
			return -1;
		}
		else
		{
			server_initialized = server_status;
		}
	}

	pthread_mutex_unlock(&mutex_server);
	// crear peticion
	struct peticion pet;
	memset(&pet, 0, sizeof(struct peticion));
	pet.op = 5;
	pet.key = key;
	// obtener resultado
	struct respuesta resp_pet;
	tratar_peticion(pet, &resp_pet);
	*result = resp_pet.status;
	retval = 1;
	return retval;
}

int rpc_1_freeresult(SVCXPRT *transp, xdrproc_t xdr_result, caddr_t result)
{
	xdr_free(xdr_result, result);

	/*
	 * Insert additional freeing code here, if needed
	 */

	return 1;
}
